#!/usr/bin/env bash
set -eo pipefail

HOST="$1"
if [[ "$HOST" == "" ]]; then
  printf "Please enter a valid host\n"
  exit 1
fi

SCRIPTS="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT="$(cd "$(dirname "$SCRIPTS")" && pwd)"
SECRETS="$ROOT/secrets"
mkdir -p "$SECRETS"
SERVER_SECRETS="$SECRETS/server"
mkdir -p "$SERVER_SECRETS"
CLIENT_SECRETS="$SECRETS/client"

HOST_SECRETS="$SECRETS/$HOST"
if [[ -d "$HOST_SECRETS" ]]; then
  printf "Client secrets already exist! Please try again..."
  exit 1
fi
mkdir -p "$HOST_SECRETS"
printf "%s" "$ID" >"$HOST_SECRETS/client.id.pub"
cp "$HOST_SECRETS/client.id.pub" "$CLIENT_SECRETS/client.id.pub"

mkserver() {
  local name

  name="$1"

  if [[ ! -f "$SERVER_SECRETS/name" ]]; then
    cp "$HOST_SECRETS/$name" "$SERVER_SECRETS/$name"
  else
    cp -f "$SERVER_SECRETS/$name" "$HOST_SECRETS/$name"
  fi
}

mkclient() {
  local name

  name="$1"

  cp "$HOST_SECRETS/$name" "$CLIENT_SECRETS/$name"
}

mkid() {
  local name

  name="$1"

  # NOTE: if you do it raw it adds a newline
  printf "%s" "$(openssl rand -base64 32)" >"$HOST_SECRETS/$name.id.pub"
}

mkpass() {
  local name

  name="$1"

  # NOTE: if you do it raw it adds a newline
  passwd="$(openssl rand -base64 32)"
  printf "%s" "$passwd" >"$HOST_SECRETS/$name.pass"
  chmod 400 "$HOST_SECRETS/$name.pass"
  printf "%s" "$(echo "$passwd" | mkpasswd --stdin)" >"$HOST_SECRETS/$name.pass.pub"
}

mkage() {
  local name

  name="$1"

  age-keygen -o "$HOST_SECRETS/$name.age" 2>&1 |
    awk '{ print $3 }' >"$HOST_SECRETS/$name.age.pub"
  chmod 400 "$HOST_SECRETS/$name.age"
}

mkssh() {
  local name
  local comment

  if [[ "$2" == "" ]]; then
    name="$1"

    ssh-keygen -q -a 100 -t ed25519 -N "" \
      -f "$HOST_SECRETS/$name.ssh"
  else
    name="$1"
    comment="$2"

    ssh-keygen -q -a 100 -t ed25519 -N "" \
      -C "$comment" \
      -f "$HOST_SECRETS/$name.ssh"
  fi

  chmod 400 "$HOST_SECRETS/$name.ssh"
}

mkssl() {
  local name
  local ca
  local subj

  if [[ "$3" == "" ]]; then
    name="$1"
    subj="$2"

    openssl genpkey -algorithm ED25519 \
      -out "$SECRETS/$name.ssl.key" >/dev/null 2>&1
    openssl req -x509 \
      -key "$SECRETS/$name.ssl.key" \
      -out "$SECRETS/$name.ssl.crt" \
      -subj "/CN=$subj" \
      -days 3650 >/dev/null 2>&1
  else
    name="$1"
    ca="$2"
    subj="$3"

    openssl genpkey -algorithm ED25519 \
      -out "$HOST_SECRETS/$name.ssl.key" >/dev/null 2>&1
    openssl req -new \
      -key "$HOST_SECRETS/$name.ssl.key" \
      -out "$HOST_SECRETS/$name.ssl.csr" \
      -subj "/CN=$subj" >/dev/null 2>&1
    openssl x509 -req \
      -in "$HOST_SECRETS/$name.ssl.csr" \
      -CA "$ca.ssl.crt" \
      -CAkey "$ca.ssl.key" \
      -CAcreateserial \
      -out "$HOST_SECRETS/$name.ssl.crt" \
      -days 3650 >/dev/null 2>&1
  fi

  chmod 400 "$HOST_SECRETS/$name.ssl.key"
}

mkparam() {
  local name

  name="$1"

  openssl dhparam -out "$HOST_SECRETS/$name.dhparam.pem"
}

mktakey() {
  local name

  name="$1"

  openvpn --genkey --secret "$HOST_SECRETS/$name.ta.key"
}

indent() {
  local text
  local amount

  text="$1"
  amount="$2"

  printf "%b" "$text" |
    sed -z "s/\\n/,/g;s/,/\\n$(printf "%${amount}s" "")/g"
}

mkage "secrets"
mkserver "secrets.age"
mkserver "secrets.age.pub"

mkssl "root-ca" "Mikoshi Root CA"
mkserver "root-ca.ssl.key"
mkserver "root-ca.ssl.crt"

mkage "mikoshi"
mkserver "mikoshi.age"
mkserver "mikoshi.age.pub"

mkssh "mikoshi"
mkserver "mikoshi.ssh"
mkserver "mikoshi.ssh.pub"

mkssl "mikoshi" "$HOST_SECRETS/root.ssl" "Mikoshi Cert"
mkserver "mikoshi.ssl.key"
mkserver "mikoshi.ssl.csr"
mkserver "mikoshi.ssl.crt"

mkparam "mikoshi"
mkserver "mikoshi.dhparam.pem"

mktakey "mikoshi"
mkserver "mikoshi.ta.key"

mkage "client"
mkclient "client.age"
mkclient "client.age.pub"

mkpass "client"
mkclient "client.pass.pub"

mkssl "client" "$HOST_SECRETS/root.ssl" "Client-$ID Cert"
mkclient "client.ssl.key"
mkclient "client.ssl.csr"
mkclient "client.ssl.crt"
